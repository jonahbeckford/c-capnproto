# Recommendation: Place this file in source control.
# Auto-generated by `./dk dksdk.project.new` of DkHelloWorld.

include(FetchContent)

function(parse_dktool_command_line)
    # The first argument is <command>. All dots will be replaced with a
    # triple underscore as a convenience and to be pretty for the user.
    if(ARGC EQUAL 0)
        message(FATAL_ERROR "Missing <command>. Usage: ./dk <command> [args]")
    endif()
    set(command ${ARGV0})
    string(REPLACE "." "___" function_name ${command})

    # Set policies (we are in a new EVAL CODE context)
    #   Included scripts do automatic cmake_policy PUSH and POP
    if(POLICY CMP0011)
        cmake_policy(SET CMP0011 NEW)
    endif()

    # Setup the binary directory
    if(NOT DKTOOL_WORKDIR)
        message(FATAL_ERROR "Illegal state. Expecting DKTOOL_WORKDIR")
    endif()
    set(CMAKE_BINARY_DIR ${DKTOOL_WORKDIR})
    set(CMAKE_CURRENT_BINARY_DIR  ${CMAKE_BINARY_DIR})

    # Include all the user scripts
    file(GLOB_RECURSE command_files LIST_DIRECTORIES FALSE
            cmake/scripts/*.cmake)
    foreach(command_file IN LISTS command_files)
        include(${command_file})
    endforeach()

    # Include all the system scripts.
    # - Since the system scripts come after the user scripts, the user scripts
    #   don't override the system scripts unless the user scripts use deferred
    #   hooks or redefine CMake built-in functions.
    if(NOT IS_DIRECTORY cmake/scripts/dksdk)
        # If this project (ex. DkHelloWorld) has the system scripts, it must
        # have all of them. Otherwise we download the system scripts.
        FetchContent_Populate(DkHelloWorld
            QUIET
            GIT_REPOSITORY https://gitlab.com/diskuv/samples/DkHelloWorld.git
            GIT_TAG 1.0
        )
        file(GLOB_RECURSE system_command_files LIST_DIRECTORIES FALSE
                ${dkhelloworld_SOURCE_DIR}/cmake/scripts/dksdk/*.cmake)
        list(APPEND command_files ${system_command_files})
        foreach(command_file IN LISTS system_command_files)
            include(${command_file})
        endforeach()
    endif()

    # Validate the <command> exists
    if(NOT COMMAND ${function_name})
        set(pretty_command_files ${command_files})
        list(TRANSFORM pretty_command_files PREPEND "  ")
        list(TRANSFORM pretty_command_files APPEND "\n")
        string(JOIN "" str_pretty_command_files ${pretty_command_files})
        message(FATAL_ERROR "No command '${command}' exists. The function '${function_name}' was searched in the following locations:
${str_pretty_command_files}")
    endif()

    # Parse the remainder of the arguments [args]
    # * Use technique from [Professional CMake: A Practical Guide - Forwarding Command Arguments]
    #   to forward arguments correctly to an inner function (the <command> function).
    cmake_parse_arguments(PARSE_ARGV 1 FWD "" "" "")
    set(quotedArgs "")
    foreach(arg IN LISTS FWD_UNPARSED_ARGUMENTS)
        string(APPEND quotedArgs " [===[${arg}]===]")
    endforeach()

    # Call the <command> function
    cmake_language(EVAL CODE "${function_name}(${quotedArgs})")
endfunction()

# DkSDK data home
if(WIN32)
    set(DKSDK_DATA_HOME "$ENV{LOCALAPPDATA}/Programs/DkSDK")
elseif(DEFINED ENV{XDG_DATA_HOME})
    set(DKSDK_DATA_HOME "$ENV{XDG_DATA_HOME}/dksdk")
else()
    set(DKSDK_DATA_HOME "$ENV{HOME}/.local/share/dksdk")
endif()

# Splat DKTOOL_CMDLINE
cmake_language(EVAL CODE "parse_dktool_command_line(${DKTOOL_CMDLINE})")
